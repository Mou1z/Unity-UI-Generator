# UI Generator

The overall idea is to make a web application which enables us to make interactive and responsive Unity UI which can then be exported in the form of C# code and in-turn be used in the Unity Editor directly.

The first half of the project is the web application. The web application gives the user an interface for creating and customizing UI and that UI is then exported by the web application in JSON format which contains all the data about the UI's elements, events, animations etc. This is the second half of the project which focuses on processing that JSON data to generate C# code which can then be directly used in Unity.

## Structure

The program is divided into folders and modules to keep the things neat and organized. The basic structure of the program is given below:

- ðŸ“ base
	- ðŸ“ elements
	- anim.cs
	- main.cs
- ðŸ“ input
	- animData.ts
	- eventsData.ts
	- uiData.ts
- ðŸ“ node_modules
- ðŸ“ resources
	- ðŸ“ Fonts
	- ðŸ“ Prefabs
	- ðŸ“ Sprites
	- ðŸ“ TextMesh Pro
- ðŸ“ src
	- ðŸ“ functions
	- main.ts
	- data.ts
- config.ts
- package.json
- package-lock.json
- tsconfig.json

All of the above files and folders will be discussed in detail later wherever appropriate however, just to give a brief overview, the `base` folder contains the code that is prewritten and is utilized while generating the output C# code. The `input` folder contains the JSON files generated by the web application. The `node_modules` folder and the node related files are there for obvious reasons. The resources folder contains everything that is used in the UI and needs to be copied to the Unity Assets folder along with the output C# file (example: Image / Sprite files, Fonts, TextMeshPro files, Prefabs etc). The `src` folder contains all the code responsible for reading the JSON (.ts) input files and converting them into C# along with the code responsible for copying the generated output files and the relevant required files to the assets folder. Finally the `config.ts` contains all important information, mostly paths to key folders / files. 

## Running the Program
In order to run the program we need to set it up first. Following are the steps which we can follow:
1. Download the `UI Generator` folder from the repository. The easier way is to clone the repository.
2. Download the three example input code files from **here** and replace the three files in `UI Generator/input` folder with the downloaded files.
3. Now we need to edit the `UI Generator/config.ts`. Most of the things are already configured. We just need to specify the `TARGET_ASSETS_FOLDER` path so that the program can copy output files to the right destination. For that we can create an empty unity project and copy paste its **Assets Folder's Path** to `config.ts`.
4. Now in order to run the program we need to `cd` into the `UI Generator` folder using windows console (or shell) and then run the following command:

		npx ts-node src/main.ts
		
5. After the command is executed it will show a message in the console saying that the process was successful. Now we can go to the Unity Editor to test the results. In the Editor there should be a file named `outputCode.cs` or whatever output name is specified in the `config.ts` file. We can attach this script to an empty object and run the game to test it. 

## Basic Working
In order to minimize complexity and bugs the program generates only the necessary code. For that we use a base (.cs) file which contains some pre-written code and the generated code is added to that file to create the final output (.cs) file.

![Code Processing Flow](https://i.imgur.com/DjMp21Q.png)

**Main Generated Code** contains the code for definitions of UI elements, event processing, functions and all the other important things. As it is generated, it is added to a copy of `main.cs` (Let's consider the copy of `main.cs` is called `output.cs`). The program adds the generated code at relevant places automatically. So you can consider `main.cs` to be somewhat of a boilerplate code. The **Generated Animation Code** is simply the code responsible for **a specific animation**, which basically means that every time an animation is processed, the program takes a copy of `anim.cs` as a base code and puts the generated animation code in that, finally it adds the resultant of that to the `output.cs`.

The program uses an object oriented approach to make the things more manageable and neat, it enables us to keep track of or/and make changes in UI elements. Another important reason of using OOP was to be able to make and process animations in a neat manner. It generally makes the processing easier. Every supported type of element has a class for-example ButtonElement, InputFieldElement, PanelElement, etc. When an instance of these classes is created an element is created as well depending upon the data passed in the constructor.
```c#
uiElement main_canvas;
uiElement button_1;

new  CanvasElement (ref  main_canvas, null, name: "mainCanvas");
new  ButtonElement (ref  button_1, main_canvas.gameObject, top: 50, left: 50, width: "30%", height: "15%", originX: 0.5, originY: 0.5);
```
The above code will create two empty objects of type `uiElement`. `uiElement` is the parent class to all the element types (CanvasElement, ButtonElement, ... etc). In the line 4, it creates a Canvas element and sets its name to 'mainCanvas' which will be its name in the Unity Editor. In the line 5, it creates a Button element at the center of it's parent element having width and height equal to 30% and 15% of its parent element respectively. The second arguments in both the constructors are for specifying the parent game objects. The Canvas has no parent so its set to `null` while the Button element needs to be a child of the Canvas element so its parent is set to `main_canvas.gameObject`. Now what is `main_canvas` ? It is a reference variable to the Canvas object. Similarly the button_1 is a reference variable to the Button object. You might be  thinking instead of passing `main_canvas` and `button_1` into the constructors I could have done the following instead :
```c#
uiElement main_canvas = CanvasElement (...);
uiElement button_1 = ButtonElement (...);
```
The above code was initially the method which was being used before the events system was added, however I discarded it because it was causing some limitations. It will be explained in detail later but to give an idea, we need a reference variable for calling the event `OnElementCreate (uiElement elementID)` inside the constructor so with the above method it won't be possible therefore we manually pass an empty object and set it equal to `this` inside the constructor before its used. You can look at the codes of elements' constructors for better understanding of what's happening here however it's not necessary as it will be explained later.

So if you look at the diagram above it will make more sense now. The program keeps track of which elements are used in the UI and only copies their classes to the `output.cs` as for-example copying SliderElement's class to the output file will be not efficient if it's not used. That is what the **Used Classes Code** refers to.

## Input Data
There are three files for input namely: `uiData.ts`, `eventsData.ts` and `animData.ts`.

 `uiData.ts` - This file contains the definitions for all the elements. Following is an example of what it can contain:
 
```javascript
export  let  uiData = {
	id: 'main_canvas',
	type: 'Canvas',
	name: 'mainCanvas',
	children: [
		{
			id: 'button_1',
			type: 'Button',
			top: 50,
			left: 50,
			originX: 0.5,
			originY: 0.5,
			width: '30%',
			height: '15%'
		}
	]
}
```

The `uiData` object contains data for all the element objects. Every object can have infinite number of child objects and those child objects can in turn have infinite number of child objects and so on. The first direct object which we must define in the `uiData` is Canvas otherwise the objects won't be visible in the game as Unity requires all the UI components to be inside a Canvas. We can name that Canvas object to anything and assign any ID to it. The IDs follow the variable naming rules so using special characters or adding spaces will cause errors. Every element must have a unique ID and these IDs are manually given in the `uiData.ts`. These IDs are used for referencing these objects in other places or input files like `eventsData.ts`. The above JSON code will be translated by the program as follows: 
```c#
uiElement main_canvas;
uiElement button_1;

new  CanvasElement (ref  main_canvas, null, name: "mainCanvas");
new  ButtonElement (ref  button_1, main_canvas.gameObject, top: 50, left: 50, originX: 0.5, originY: 0.5, width: "30%", height: "15%");
```
You might have noticed this code is similar to the code discussed in the previous section however the order or the arguments passed in line 5 is different. The order of arguments does not matter and in the above code the order corresponds to the order in which the properties are mentioned in the JSON because of the way the program reads the data and processes it. Note: The order doesn't matter except for the first two arguments, since the remaining are keyword arguments. Following is the general syntax of the constructors:

```c#
new ElementClassName (reference_variable, parent_gameobject, ...);
```

The keyword arguments are convenient here so that we don't need to write the JSON in a rigid manner - we can write the properties in any order / sequence and it will still be valid. Apart from that almost every property has a default value so we don't even need to define all the properties for an object. For-example if `originX` and/or `originY` are missing, their values will be set to 0.5 by default. 

`eventsData.ts` - This file controls all the events. Examples of some events start OnStart, OnElementCreate, OnKeyPress, OnAnimationStart, OnAnimationEnd, etc. In this file we can reference the element objects we created in `uiData.ts` to specify when they are created, shown, hidden or changed.

For-example we can toggle an object's visibility when a key is pressed. To do that we will write something like this in `eventsData.ts` (Note: It's is being assumed that we have the same code in the `uiData.ts` as shown in the previous section) :

```js
export  let  unityEvents: string [] = [];

export  let  eventsData: any = {
	'onStart': [
		{
			type:  'create',
			data: { targetID:  'main_canvas' }
		},
		{
			type:  'create',
			data: { targetID:  'button_1' }
		},
		{
			type:  'disable',
			data: { targetID:  'button_1' }
		}
	],
	'onKeyPress': [
		{
			condition: [
				{
				comparator:  '==',
				arguments: ['{keyCode}', 'Q']
				}
			],
			type:  'toggle',
			data: { targetID:  'button_1' }
		}
	]
};
```

The `export  let unityEvents: string []  =  [];`  part will be explained later, let's first focus on the *eventsData* object. It has a key called *onStart* and as its value it has an array of objects. Each object in this array represents a separate *action*. The list of all the available *actions* and *events* is given **here**.

The general syntax of an *action* is as follows:
```js
{
	condition: [] // Optional
	type: 'type of action',
	data: { /* any data to be passed */ }
}
```
Every action object can support an optional conditional and the action will only be performed if the condition is met, we can also add multiple conditions that's that the key 'condition' has an array as a value. The method if adding conditions will be explained shortly after, let focus on making a simple action for now. In the above code, there are two required keys that must be specified, first one is the 'type' of action which can be create, toggle, disable, enable, triggerAnimation etc. The second required key is the 'data' that is required by that action. For simple actions like toggle, disable, enable etc, we just need to specify a 'targetID' in the data which represents the element object on which we want to perform that action. Here is a chunk of code from the example:
```js
'onStart': [
	{
		type:  'create',
		data: { targetID:  'main_canvas' }
	},
	{
		type:  'create',
		data: { targetID:  'button_1' }
	},
	{
		type:  'disable',
		data: { targetID:  'button_1' }
	}
],
```
Looking at this you should be able to see there are three different actions under the 'onStart' event and none of them require a condition which means when the game starts all of these actions will be performed. If you look at the first two actions, we are creating the `main_canvas` and `button_1` (Note: The `main_canvas` and `button_1` are defined in the uiData.ts that's why we are able to reference them here, otherwise it will give an error during compilation). By default when an element object is created, it is visible (enabled) in-game, however we want the `button_1` to be invisible (disabled) initially so in the third action we disable the button. Also note that if we write the actions in the wrong order (for-example: disable the button before creating it), it might cause problems. 

*The future goal is to be able to sort the actions based on priorities no matter in what order they are written in the `eventsData` and show an error during compile time in case the problem persists even after sorting them.*

Now let's look at the next part of the code:
```js
'onKeyPress': [
	{
		condition: [
			{
				comparator:  '==',
				arguments: ['{keyCode}', 'Q']
			}
		],
		type:  'toggle',
		data: { targetID:  'button_1' }
	}
]
```
In this above code we have an event and under that we have one action to be performed however it has a conditional in it. The condition key has an array as a value, as mentioned before, it is so we can add multiple conditionals - each object in this array represents a separate condition. The general syntax for writing a condition is as follows:

```js
{
	comparator: 'some_comparator' // Comparator of choice: >, <, <=, ==, >=
	arguments: ['item_1', 'item_2'] // The items: values or variables to be compared.
}
```

Now if you look at the code, it should make sense to you that when the key Q is pressed we want the `button_1` to toggle. The term `keyCode` is enclosed in curly braces to tell the compiler that it is a variable term, this term is actually a parameter of the `OnKeyPress` event. In Unity C# code the compiled `OnKeyPress` event looks something like this.

```c#
public void onKeyPress (KeyCode keyCode) {
	if (keyCode == KeyCode.Q) { 
		button_1.enabled = !button_1.enabled; 
		button_1.updateElement (enabled: true); 
	}
}
```

As you can in the above code the term `keyCode` is an argument and in `eventsData` we have enclosed it in curly braces, it is so that the compiler can know how to treat the value being compared accurately. Since the type of `keyCode` is KeyCode therefore writing something like `if (keyCode == Q)` will be invalid, however since the compiler knows that keyCode is a variable, it searches for its type, once it finds out that keyCode is of type KeyCode, it converts `Q` to `KeyCode.Q`. Similarly if it was a string it would have enclosed Q in double quotation marks. 

At the point of writing this guide the conditionals are not completely robust since I need to add checks for more cases ways it should handle it however its is functional. 

Note: If we don't enclose any variable term in braces, the conditional might still work. It will simply piece the terms together to create the conditional statement without processing them / checking for types etc. (`if (item_1 comparator item_2)`). However it will have risk of showing errors on runtime (during gameplay).

If we want multiple conditions we can add multiple condition objects in the 'conditional' array, as explained before.

*Currently the ability to detect a combination of keys is not added however it is in the to-do list.*

`animData.ts` is an optional file which can be used for convenience. It can contain a set of pre-defined keyframes that can be referenced in `eventsData.ts` for creating animations.

This app gives us the ability to animate UI elements and the future goal is to be able to make all kinds of complex animations. Currently the animation system is fairly robust however there are a few limitations and missing features like the support for 'bezier curve' etc .

In order to animate an object we need to call a 'triggerAnimation' action under an event. For-example, if want the button to turn Red when I press the 'R' key and Green when I press the 'G' key, I'll add the following code in the eventsData.ts under OnKeyPress :

```js
'onKeyPress': [
	{
		condition: [
			{
				comparator: '==',
				arguments: ['{keyCode}', 'R']
			}
		],
		type: 'animationTrigger',
		data: {
			id: 'a1',
			targetID: 'button_1',
			delay: 0,
			repeat: 1,
			duration: 1000,
			keyframes: {
				'0%': {
					normalColor: '#FFFFFFFF'
				},
				'100%': {
					normalColor: '#FF0000FF'
				}
			}
		}
	},
	{
		condition: [
			{
				comparator: '==',
				arguments: ['{keyCode}', 'G']
			}
		],
		type: 'animationTrigger',
		data: {
			id: 'a2',
			targetID: 'button_1',
			delay: 0,
			repeat: 1,
			duration: 1000,
			keyframes: {
				'0%': {
					normalColor: '#FFFFFFFF'
				},
				'100%': {
					normalColor: '#00FF00FF'
				}
			}
		}
	}
]
```
If you observe the code above you'll notice that in 'animationTrigger' actions we are passing more things in the 'data' of the action. 

- `targetID` - The ID of the target element on which the animation should be played.
- `delay` - The delay (in milliseconds) after which the animation should play. This property is optional and if it's not specified, it's value is taken as **0 ms** by default.
- `repeat` - The number of times the animation should repeat. This property is optional and it's considered as 1 by default. In order to set the animation to play for an infinite number of times we can set it to **-1**.
- `duration` - The duration (in milliseconds) of the animation. Specifying smaller durations will speed up the animation.
